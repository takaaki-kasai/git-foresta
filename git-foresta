#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  package Error;use strict;use warnings;use vars qw($VERSION);use 5.004;$VERSION="0.17024";use overload ('""'=>'stringify','0+'=>'value','bool'=>sub {return 1},'fallback'=>1);$Error::Depth=0;$Error::Debug=0;@Error::STACK=();$Error::THROWN=undef;my$LAST;my%ERROR;sub _throw_Error_Simple {my$args=shift;return Error::Simple->new($args->{'text'})}$Error::ObjectifyCallback=\&_throw_Error_Simple;use Scalar::Util ();sub import {shift;my@tags=@_;local$Exporter::ExportLevel=$Exporter::ExportLevel + 1;@tags=grep {if($_ eq ':warndie'){Error::WarnDie->import();0}else {1}}@tags;Error::subs->import(@tags)}sub prior {shift;return$LAST unless @_;my$pkg=shift;return exists$ERROR{$pkg}? $ERROR{$pkg}: undef unless ref($pkg);my$obj=$pkg;my$err=undef;if($obj->isa('HASH')){$err=$obj->{'__Error__'}if exists$obj->{'__Error__'}}elsif($obj->isa('GLOB')){$err=${*$obj}{'__Error__'}if exists ${*$obj}{'__Error__'}}$err}sub flush {shift;unless (@_){$LAST=undef;return}my$pkg=shift;return unless ref($pkg);undef$ERROR{$pkg}if defined$ERROR{$pkg}}sub stacktrace {my$self=shift;return$self->{'-stacktrace'}if exists$self->{'-stacktrace'};my$text=exists$self->{'-text'}? $self->{'-text'}: "Died";$text .= sprintf(" at %s line %d.\n",$self->file,$self->line)unless($text =~ /\n$/s);$text}sub associate {my$err=shift;my$obj=shift;return unless ref($obj);if($obj->isa('HASH')){$obj->{'__Error__'}=$err}elsif($obj->isa('GLOB')){${*$obj}{'__Error__'}=$err}$obj=ref($obj);$ERROR{ref($obj)}=$err;return}sub new {my$self=shift;my($pkg,$file,$line)=caller($Error::Depth);my$err=bless {'-package'=>$pkg,'-file'=>$file,'-line'=>$line,@_ },$self;$err->associate($err->{'-object'})if(exists$err->{'-object'});if($Error::Debug){require Carp;local$Carp::CarpLevel=$Error::Depth;my$text=defined($err->{'-text'})? $err->{'-text'}: "Error";my$trace=Carp::longmess($text);$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;$err->{'-stacktrace'}=$trace}$@=$LAST=$ERROR{$pkg}=$err}sub throw {my$self=shift;local$Error::Depth=$Error::Depth + 1;$self=$self->new(@_)unless ref($self);die$Error::THROWN=$self}sub with {my$self=shift;local$Error::Depth=$Error::Depth + 1;$self->new(@_)}sub record {my$self=shift;local$Error::Depth=$Error::Depth + 1;$self->new(@_)}sub catch {my$pkg=shift;my$code=shift;my$clauses=shift || {};my$catch=$clauses->{'catch'}||= [];unshift @$catch,$pkg,$code;$clauses}sub object {my$self=shift;exists$self->{'-object'}? $self->{'-object'}: undef}sub file {my$self=shift;exists$self->{'-file'}? $self->{'-file'}: undef}sub line {my$self=shift;exists$self->{'-line'}? $self->{'-line'}: undef}sub text {my$self=shift;exists$self->{'-text'}? $self->{'-text'}: undef}sub stringify {my$self=shift;defined$self->{'-text'}? $self->{'-text'}: "Died"}sub value {my$self=shift;exists$self->{'-value'}? $self->{'-value'}: undef}package Error::Simple;use vars qw($VERSION);$VERSION="0.17024";@Error::Simple::ISA=qw(Error);sub new {my$self=shift;my$text="" .shift;my$value=shift;my(@args)=();local$Error::Depth=$Error::Depth + 1;@args=(-file=>$1,-line=>$2)if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);push(@args,'-value',0 + $value)if defined($value);$self->SUPER::new(-text=>$text,@args)}sub stringify {my$self=shift;my$text=$self->SUPER::stringify;$text .= sprintf(" at %s line %d.\n",$self->file,$self->line)unless($text =~ /\n$/s);$text}package Error::subs;use Exporter ();use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);@EXPORT_OK=qw(try with finally except otherwise);%EXPORT_TAGS=(try=>\@EXPORT_OK);@ISA=qw(Exporter);sub run_clauses ($$$\@) {my($clauses,$err,$wantarray,$result)=@_;my$code=undef;$err=$Error::ObjectifyCallback->({'text'=>$err})unless ref($err);CATCH: {my$catch;if(defined($catch=$clauses->{'catch'})){my$i=0;CATCHLOOP: for(;$i < @$catch ;$i += 2){my$pkg=$catch->[$i];unless(defined$pkg){splice(@$catch,$i,2,$catch->[$i+1]->($err));$i -= 2;next CATCHLOOP}elsif(Scalar::Util::blessed($err)&& $err->isa($pkg)){$code=$catch->[$i+1];while(1){my$more=0;local($Error::THROWN,$@);my$ok=eval {$@=$err;if($wantarray){@{$result}=$code->($err,\$more)}elsif(defined($wantarray)){@{$result}=();$result->[0]=$code->($err,\$more)}else {$code->($err,\$more)}1};if($ok){next CATCHLOOP if$more;undef$err}else {$err=$@ || $Error::THROWN;$err=$Error::ObjectifyCallback->({'text'=>$err})unless ref($err)}last CATCH}}}}my$owise;if(defined($owise=$clauses->{'otherwise'})){my$code=$clauses->{'otherwise'};my$more=0;local($Error::THROWN,$@);my$ok=eval {$@=$err;if($wantarray){@{$result}=$code->($err,\$more)}elsif(defined($wantarray)){@{$result}=();$result->[0]=$code->($err,\$more)}else {$code->($err,\$more)}1};if($ok){undef$err}else {$err=$@ || $Error::THROWN;$err=$Error::ObjectifyCallback->({'text'=>$err})unless ref($err)}}}$err}sub try (&;$) {my$try=shift;my$clauses=@_ ? shift : {};my$ok=0;my$err=undef;my@result=();unshift@Error::STACK,$clauses;my$wantarray=wantarray();do {local$Error::THROWN=undef;local $@=undef;$ok=eval {if($wantarray){@result=$try->()}elsif(defined$wantarray){$result[0]=$try->()}else {$try->()}1};$err=$@ || $Error::THROWN unless$ok};shift@Error::STACK;$err=run_clauses($clauses,$err,wantarray,@result)unless($ok);$clauses->{'finally'}->()if(defined($clauses->{'finally'}));if (defined($err)){if (Scalar::Util::blessed($err)&& $err->can('throw')){throw$err}else {die$err}}wantarray ? @result : $result[0]}sub with (&;$) {@_}sub finally (&) {my$code=shift;my$clauses={'finally'=>$code };$clauses}sub except (&;$) {my$code=shift;my$clauses=shift || {};my$catch=$clauses->{'catch'}||= [];my$sub=sub {my$ref;my(@array)=$code->($_[0]);if(@array==1 && ref($array[0])){$ref=$array[0];$ref=[%$ref ]if(UNIVERSAL::isa($ref,'HASH'))}else {$ref=\@array}@$ref};unshift @{$catch},undef,$sub;$clauses}sub otherwise (&;$) {my$code=shift;my$clauses=shift || {};if(exists$clauses->{'otherwise'}){require Carp;Carp::croak("Multiple otherwise clauses")}$clauses->{'otherwise'}=$code;$clauses}1;package Error::WarnDie;sub gen_callstack($) {my ($start)=@_;require Carp;local$Carp::CarpLevel=$start;my$trace=Carp::longmess("");$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;my@callstack=split(m/\n/,$trace);return@callstack}my$old_DIE;my$old_WARN;sub DEATH {my ($e)=@_;local$SIG{__DIE__}=$old_DIE if(defined$old_DIE);die @_ if $^S;my ($etype,$message,$location,@callstack);if (ref($e)&& $e->isa("Error")){$etype="exception of type " .ref($e);$message=$e->text;$location=$e->file .":" .$e->line;@callstack=split(m/\n/,$e->stacktrace)}else {die$e if($e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/);$etype="perl error";my$stackdepth=0;while(caller($stackdepth)=~ m/^Error(?:$|::)/){$stackdepth++}@callstack=gen_callstack($stackdepth + 1);$message="$e";chomp$message;if ($message =~ s/ at (.*?) line (\d+)\.$//){$location=$1 .":" .$2}else {my@caller=caller($stackdepth);$location=$caller[1].":" .$caller[2]}}shift@callstack;my$callstack=join("",map {"$_\n"}@callstack);die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n"}sub TAXES {my ($message)=@_;local$SIG{__WARN__}=$old_WARN if(defined$old_WARN);$message =~ s/ at .*? line \d+\.$//;chomp$message;my@callstack=gen_callstack(1);my$location=shift@callstack;$message .= $location;my$callstack=join("",map {"$_\n"}@callstack);warn "$message:\n$callstack"}sub import {$old_DIE=$SIG{__DIE__};$old_WARN=$SIG{__WARN__};$SIG{__DIE__}=\&DEATH;$SIG{__WARN__}=\&TAXES}1;
ERROR

$fatpacked{"Error/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_SIMPLE';
  use strict;use warnings;use vars qw($VERSION);$VERSION="0.17024";use Error;1;
ERROR_SIMPLE

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  package Git;use 5.008;use strict;BEGIN {our ($VERSION,@ISA,@EXPORT,@EXPORT_OK);$VERSION='0.41';require Exporter;@ISA=qw(Exporter);@EXPORT=qw(git_cmd_try);@EXPORT_OK=qw(command command_oneline command_noisy command_output_pipe command_input_pipe command_close_pipe command_bidi_pipe command_close_bidi_pipe version exec_path html_path hash_object git_cmd_try remote_refs prompt get_tz_offset credential credential_read credential_write temp_acquire temp_is_locked temp_release temp_reset temp_path);use Carp qw(carp croak);use Error qw(:try);use Cwd qw(abs_path cwd);use IPC::Open2 qw(open2);use Fcntl qw(SEEK_SET SEEK_CUR);use Time::Local qw(timegm)}sub repository {my$class=shift;my@args=@_;my%opts=();my$self;if (defined$args[0]){if ($#args % 2!=1){$#args==0 or throw Error::Simple("bad usage");%opts=(Directory=>$args[0])}else {%opts=@args}}if (not defined$opts{Repository}and not defined$opts{WorkingCopy}and not defined$opts{Directory}){$opts{Directory}='.'}if (defined$opts{Directory}){-d $opts{Directory}or throw Error::Simple("Directory not found: $opts{Directory} $!");my$search=Git->repository(WorkingCopy=>$opts{Directory});my$dir;try {$dir=$search->command_oneline(['rev-parse','--git-dir'],STDERR=>0)}catch Git::Error::Command with {$dir=undef};if ($dir){$dir =~ m#^/# or $dir=$opts{Directory}.'/' .$dir;$opts{Repository}=abs_path($dir);my$prefix=$search->command_oneline('rev-parse','--show-prefix');$dir=abs_path($opts{Directory}).'/';if ($prefix){if (substr($dir,-length($prefix))ne $prefix){throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix")}substr($dir,-length($prefix))=''}$opts{WorkingCopy}=$dir;$opts{WorkingSubdir}=$prefix}else {$dir=$opts{Directory};unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD"){throw Error::Simple("fatal: Not a git repository: $dir")}my$search=Git->repository(Repository=>$dir);try {$search->command('symbolic-ref','HEAD')}catch Git::Error::Command with {throw Error::Simple("fatal: Not a git repository: $dir")}$opts{Repository}=abs_path($dir)}delete$opts{Directory}}$self={opts=>\%opts };bless$self,$class}sub command {my ($fh,$ctx)=command_output_pipe(@_);if (not defined wantarray){_cmd_close($ctx,$fh)}elsif (not wantarray){local $/;my$text=<$fh>;try {_cmd_close($ctx,$fh)}catch Git::Error::Command with {my$E=shift;$E->{'-outputref'}=\$text;throw$E};return$text}else {my@lines=<$fh>;defined and chomp for@lines;try {_cmd_close($ctx,$fh)}catch Git::Error::Command with {my$E=shift;$E->{'-outputref'}=\@lines;throw$E};return@lines}}sub command_oneline {my ($fh,$ctx)=command_output_pipe(@_);my$line=<$fh>;defined$line and chomp$line;try {_cmd_close($ctx,$fh)}catch Git::Error::Command with {my$E=shift;$E->{'-outputref'}=\$line;throw$E};return$line}sub command_output_pipe {_command_common_pipe('-|',@_)}sub command_input_pipe {_command_common_pipe('|-',@_)}sub command_close_pipe {my ($self,$fh,$ctx)=_maybe_self(@_);$ctx ||= '<unknown>';_cmd_close($ctx,$fh)}sub command_bidi_pipe {my ($pid,$in,$out);my ($self)=_maybe_self(@_);local%ENV=%ENV;my$cwd_save=undef;if ($self){shift;$cwd_save=cwd();_setup_git_cmd_env($self)}$pid=open2($in,$out,'git',@_);chdir($cwd_save)if$cwd_save;return ($pid,$in,$out,join(' ',@_))}sub command_close_bidi_pipe {local $?;my ($self,$pid,$in,$out,$ctx)=_maybe_self(@_);_cmd_close($ctx,(grep {defined}($in,$out)));waitpid$pid,0;if ($? >> 8){throw Git::Error::Command($ctx,$? >>8)}}sub command_noisy {my ($self,$cmd,@args)=_maybe_self(@_);_check_valid_cmd($cmd);my$pid=fork;if (not defined$pid){throw Error::Simple("fork failed: $!")}elsif ($pid==0){_cmd_exec($self,$cmd,@args)}if (waitpid($pid,0)> 0 and $?>>8!=0){throw Git::Error::Command(join(' ',$cmd,@args),$? >> 8)}}sub version {my$verstr=command_oneline('--version');$verstr =~ s/^git version //;$verstr}sub exec_path {command_oneline('--exec-path')}sub html_path {command_oneline('--html-path')}sub get_tz_offset {my$t=shift || time;my$gm=timegm(localtime($t));my$sign=qw(+ + -)[$gm <=> $t ];return sprintf("%s%02d%02d",$sign,(gmtime(abs($t - $gm)))[2,1])}sub prompt {my ($prompt,$isPassword)=@_;my$ret;if (exists$ENV{'GIT_ASKPASS'}){$ret=_prompt($ENV{'GIT_ASKPASS'},$prompt)}if (!defined$ret && exists$ENV{'SSH_ASKPASS'}){$ret=_prompt($ENV{'SSH_ASKPASS'},$prompt)}if (!defined$ret){print STDERR$prompt;STDERR->flush;if (defined$isPassword && $isPassword){require Term::ReadKey;Term::ReadKey::ReadMode('noecho');$ret='';while (defined(my$key=Term::ReadKey::ReadKey(0))){last if$key =~ /[\012\015]/;$ret .= $key}Term::ReadKey::ReadMode('restore');print STDERR "\n";STDERR->flush}else {chomp($ret=<STDIN>)}}return$ret}sub _prompt {my ($askpass,$prompt)=@_;return unless length$askpass;$prompt =~ s/\n/ /g;my$ret;open my$fh,"-|",$askpass,$prompt or return;$ret=<$fh>;$ret =~ s/[\015\012]//g;close ($fh);return$ret}sub repo_path {$_[0]->{opts}->{Repository}}sub wc_path {$_[0]->{opts}->{WorkingCopy}}sub wc_subdir {$_[0]->{opts}->{WorkingSubdir}||= ''}sub wc_chdir {my ($self,$subdir)=@_;$self->wc_path()or throw Error::Simple("bare repository");-d $self->wc_path().'/'.$subdir or throw Error::Simple("subdir not found: $subdir $!");$self->{opts}->{WorkingSubdir}=$subdir}sub config {return _config_common({},@_)}sub config_bool {my$val=scalar _config_common({'kind'=>'--bool'},@_);if (!defined$val){return undef}else {return$val eq 'true'}}sub config_path {return _config_common({'kind'=>'--path'},@_)}sub config_int {return scalar _config_common({'kind'=>'--int'},@_)}sub _config_common {my ($opts)=shift @_;my ($self,$var)=_maybe_self(@_);try {my@cmd=('config',$opts->{'kind'}? $opts->{'kind'}: ());unshift@cmd,$self if$self;if (wantarray){return command(@cmd,'--get-all',$var)}else {return command_oneline(@cmd,'--get',$var)}}catch Git::Error::Command with {my$E=shift;if ($E->value()==1){return}else {throw$E}}}sub get_colorbool {my ($self,$var)=@_;my$stdout_to_tty=(-t STDOUT)? "true" : "false";my$use_color=$self->command_oneline('config','--get-colorbool',$var,$stdout_to_tty);return ($use_color eq 'true')}sub get_color {my ($self,$slot,$default)=@_;my$color=$self->command_oneline('config','--get-color',$slot,$default);if (!defined$color){$color=""}return$color}sub remote_refs {my ($self,$repo,$groups,$refglobs)=_maybe_self(@_);my@args;if (ref$groups eq 'ARRAY'){for (@$groups){if ($_ eq 'heads'){push (@args,'--heads')}elsif ($_ eq 'tags'){push (@args,'--tags')}else {}}}push (@args,$repo);if (ref$refglobs eq 'ARRAY'){push (@args,@$refglobs)}my@self=$self ? ($self): ();my ($fh,$ctx)=Git::command_output_pipe(@self,'ls-remote',@args);my%refs;while (<$fh>){chomp;my ($hash,$ref)=split(/\t/,$_,2);$refs{$ref}=$hash}Git::command_close_pipe(@self,$fh,$ctx);return \%refs}sub ident {my ($self,$type)=_maybe_self(@_);my$identstr;if (lc$type eq lc 'committer' or lc$type eq lc 'author'){my@cmd=('var','GIT_'.uc($type).'_IDENT');unshift@cmd,$self if$self;$identstr=command_oneline(@cmd)}else {$identstr=$type}if (wantarray){return$identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/}else {return$identstr}}sub ident_person {my ($self,@ident)=_maybe_self(@_);$#ident==0 and @ident=$self ? $self->ident($ident[0]): ident($ident[0]);return "$ident[0] <$ident[1]>"}sub hash_object {my ($self,$type,$file)=_maybe_self(@_);command_oneline('hash-object','-t',$type,$file)}sub hash_and_insert_object {my ($self,$filename)=@_;carp "Bad filename \"$filename\"" if$filename =~ /[\r\n]/;$self->_open_hash_and_insert_object_if_needed();my ($in,$out)=($self->{hash_object_in},$self->{hash_object_out});unless (print$out $filename,"\n"){$self->_close_hash_and_insert_object();throw Error::Simple("out pipe went bad")}chomp(my$hash=<$in>);unless (defined($hash)){$self->_close_hash_and_insert_object();throw Error::Simple("in pipe went bad")}return$hash}sub _open_hash_and_insert_object_if_needed {my ($self)=@_;return if defined($self->{hash_object_pid});($self->{hash_object_pid},$self->{hash_object_in},$self->{hash_object_out},$self->{hash_object_ctx})=$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters))}sub _close_hash_and_insert_object {my ($self)=@_;return unless defined($self->{hash_object_pid});my@vars=map {'hash_object_' .$_}qw(pid in out ctx);command_close_bidi_pipe(@$self{@vars});delete @$self{@vars}}sub cat_blob {my ($self,$sha1,$fh)=@_;$self->_open_cat_blob_if_needed();my ($in,$out)=($self->{cat_blob_in},$self->{cat_blob_out});unless (print$out $sha1,"\n"){$self->_close_cat_blob();throw Error::Simple("out pipe went bad")}my$description=<$in>;if ($description =~ / missing$/){carp "$sha1 doesn't exist in the repository";return -1}if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/){carp "Unexpected result returned from git cat-file";return -1}my$size=$1;my$blob;my$bytesLeft=$size;while (1){last unless$bytesLeft;my$bytesToRead=$bytesLeft < 1024 ? $bytesLeft : 1024;my$read=read($in,$blob,$bytesToRead);unless (defined($read)){$self->_close_cat_blob();throw Error::Simple("in pipe went bad")}unless (print$fh $blob){$self->_close_cat_blob();throw Error::Simple("couldn't write to passed in filehandle")}$bytesLeft -= $read}my$newline;my$read=read($in,$newline,1);unless (defined($read)){$self->_close_cat_blob();throw Error::Simple("in pipe went bad")}unless ($read==1 && $newline eq "\n"){$self->_close_cat_blob();throw Error::Simple("didn't find newline after blob")}return$size}sub _open_cat_blob_if_needed {my ($self)=@_;return if defined($self->{cat_blob_pid});($self->{cat_blob_pid},$self->{cat_blob_in},$self->{cat_blob_out},$self->{cat_blob_ctx})=$self->command_bidi_pipe(qw(cat-file --batch))}sub _close_cat_blob {my ($self)=@_;return unless defined($self->{cat_blob_pid});my@vars=map {'cat_blob_' .$_}qw(pid in out ctx);command_close_bidi_pipe(@$self{@vars});delete @$self{@vars}}sub credential_read {my ($self,$reader)=_maybe_self(@_);my%credential;while (<$reader>){chomp;if ($_ eq ''){last}elsif (!/^([^=]+)=(.*)$/){throw Error::Simple("unable to parse git credential data:\n$_")}$credential{$1}=$2}return%credential}sub credential_write {my ($self,$writer,$credential)=_maybe_self(@_);my ($key,$value);while (($key,$value)=each %$credential){if (!defined$key ||!length$key){throw Error::Simple("credential key empty or undefined")}elsif ($key =~ /[=\n\0]/){throw Error::Simple("credential key contains invalid characters: $key")}elsif (defined$value && $value =~ /[\n\0]/){throw Error::Simple("credential value for key=$key contains invalid characters: $value")}}for$key (sort {return -1 if$a eq 'url';return 1 if$b eq 'url';return$a cmp $b}keys %$credential){if (defined$credential->{$key}){print$writer $key,'=',$credential->{$key},"\n"}}print$writer "\n"}sub _credential_run {my ($self,$credential,$op)=_maybe_self(@_);my ($pid,$reader,$writer,$ctx)=command_bidi_pipe('credential',$op);credential_write$writer,$credential;close$writer;if ($op eq "fill"){%$credential=credential_read$reader}if (<$reader>){throw Error::Simple("unexpected output from git credential $op response:\n$_\n")}command_close_bidi_pipe($pid,$reader,undef,$ctx)}sub credential {my ($self,$credential,$op_or_code)=(_maybe_self(@_),'fill');if ('CODE' eq ref$op_or_code){_credential_run$credential,'fill';my$ret=$op_or_code->($credential);if (defined$ret){_credential_run$credential,$ret ? 'approve' : 'reject'}return$ret}else {_credential_run$credential,$op_or_code}}{my (%TEMP_FILEMAP,%TEMP_FILES);sub temp_acquire {my$temp_fd=_temp_cache(@_);$TEMP_FILES{$temp_fd}{locked}=1;$temp_fd}sub temp_is_locked {my ($self,$name)=_maybe_self(@_);my$temp_fd=\$TEMP_FILEMAP{$name};defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked}}sub temp_release {my ($self,$temp_fd,$trunc)=_maybe_self(@_);if (exists$TEMP_FILEMAP{$temp_fd}){$temp_fd=$TEMP_FILES{$temp_fd}}unless ($TEMP_FILES{$temp_fd}{locked}){carp "Attempt to release temp file '",$temp_fd,"' that has not been locked"}temp_reset($temp_fd)if$trunc and $temp_fd->opened;$TEMP_FILES{$temp_fd}{locked}=0;undef}sub _temp_cache {my ($self,$name)=_maybe_self(@_);_verify_require();my$temp_fd=\$TEMP_FILEMAP{$name};if (defined $$temp_fd and $$temp_fd->opened){if ($TEMP_FILES{$$temp_fd}{locked}){throw Error::Simple("Temp file with moniker '" .$name ."' already in use")}}else {if (defined $$temp_fd){carp "Temp file '",$name,"' was closed. Opening replacement."}my$fname;my$tmpdir;if (defined$self){$tmpdir=$self->repo_path()}my$n=$name;$n =~ s/\W/_/g;($$temp_fd,$fname)=File::Temp::tempfile("Git_${n}_XXXXXX",UNLINK=>1,DIR=>$tmpdir,)or throw Error::Simple("couldn't open new temp file");$$temp_fd->autoflush;binmode $$temp_fd;$TEMP_FILES{$$temp_fd}{fname}=$fname}$$temp_fd}sub _verify_require {eval {require File::Temp;require File::Spec};$@ and throw Error::Simple($@)}sub temp_reset {my ($self,$temp_fd)=_maybe_self(@_);truncate$temp_fd,0 or throw Error::Simple("couldn't truncate file");sysseek($temp_fd,0,SEEK_SET)and seek($temp_fd,0,SEEK_SET)or throw Error::Simple("couldn't seek to beginning of file");sysseek($temp_fd,0,SEEK_CUR)==0 and tell($temp_fd)==0 or throw Error::Simple("expected file position to be reset")}sub temp_path {my ($self,$temp_fd)=_maybe_self(@_);if (exists$TEMP_FILEMAP{$temp_fd}){$temp_fd=$TEMP_FILEMAP{$temp_fd}}$TEMP_FILES{$temp_fd}{fname}}sub END {unlink values%TEMP_FILEMAP if%TEMP_FILEMAP}}{package Git::Error::Command;@Git::Error::Command::ISA=qw(Error);sub new {my$self=shift;my$cmdline='' .shift;my$value=0 + shift;my$outputref=shift;my(@args)=();local$Error::Depth=$Error::Depth + 1;push(@args,'-cmdline',$cmdline);push(@args,'-value',$value);push(@args,'-outputref',$outputref);$self->SUPER::new(-text=>'command returned error',@args)}sub stringify {my$self=shift;my$text=$self->SUPER::stringify;$self->cmdline().': ' .$text .': ' .$self->value()."\n"}sub cmdline {my$self=shift;$self->{'-cmdline'}}sub cmd_output {my$self=shift;my$ref=$self->{'-outputref'};defined$ref or undef;if (ref$ref eq 'ARRAY'){return @$ref}else {return $$ref}}}sub git_cmd_try(&$) {my ($code,$errmsg)=@_;my@result;my$err;my$array=wantarray;try {if ($array){@result=&$code}else {$result[0]=&$code}}catch Git::Error::Command with {my$E=shift;$err=$errmsg;$err =~ s/\%s/$E->cmdline()/ge;$err =~ s/\%d/$E->value()/ge};$err and croak$err;return$array ? @result : $result[0]}sub _maybe_self {UNIVERSAL::isa($_[0],'Git')? @_ : (undef,@_)}sub _check_valid_cmd {my ($cmd)=@_;$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd")}sub _command_common_pipe {my$direction=shift;my ($self,@p)=_maybe_self(@_);my (%opts,$cmd,@args);if (ref$p[0]){($cmd,@args)=@{shift@p};%opts=ref$p[0]? %{$p[0]}: @p}else {($cmd,@args)=@p}_check_valid_cmd($cmd);my$fh;if ($^O eq 'MSWin32'){$direction eq '-|' or die 'input pipe for ActiveState not implemented';tie (*ACPIPE,'Git::activestate_pipe',$cmd,@args);$fh=*ACPIPE}else {my$pid=open($fh,$direction);if (not defined$pid){throw Error::Simple("open failed: $!")}elsif ($pid==0){if ($opts{STDERR}){open (STDERR,'>&',$opts{STDERR})or die "dup failed: $!"}elsif (defined$opts{STDERR}){open (STDERR,'>','/dev/null')or die "opening /dev/null failed: $!"}_cmd_exec($self,$cmd,@args)}}return wantarray ? ($fh,join(' ',$cmd,@args)): $fh}sub _cmd_exec {my ($self,@args)=@_;_setup_git_cmd_env($self);_execv_git_cmd(@args);die qq[exec "@args" failed: $!]}sub _setup_git_cmd_env {my$self=shift;if ($self){$self->repo_path()and $ENV{'GIT_DIR'}=$self->repo_path();$self->repo_path()and $self->wc_path()and $ENV{'GIT_WORK_TREE'}=$self->wc_path();$self->wc_path()and chdir($self->wc_path());$self->wc_subdir()and chdir($self->wc_subdir())}}sub _execv_git_cmd {exec('git',@_)}sub _cmd_close {my$ctx=shift @_;for my$fh (@_){if (close$fh){}elsif ($!){carp "error closing pipe: $!"}elsif ($? >> 8){throw Git::Error::Command($ctx,$? >> 8)}}}sub DESTROY {my ($self)=@_;$self->_close_hash_and_insert_object();$self->_close_cat_blob()}package Git::activestate_pipe;use strict;sub TIEHANDLE {my ($class,@params)=@_;my@data=qx{git @params};bless {i=>0,data=>\@data },$class}sub READLINE {my$self=shift;if ($self->{i}>= scalar @{$self->{data}}){return undef}my$i=$self->{i};if (wantarray){$self->{i}=$#{$self->{'data'}}+ 1;return splice(@{$self->{'data'}},$i)}$self->{i}=$i + 1;return$self->{'data'}->[$i ]}sub CLOSE {my$self=shift;delete$self->{data};delete$self->{i}}sub EOF {my$self=shift;return ($self->{i}>= scalar @{$self->{data}})}1;
GIT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
#  git-森林
#  text-based tree visualisation
#  Copyright © Jan Engelhardt <jengelh [at] medozas de>, 2008
#
#  Modified work:
#  Copyright (C) 2017 Takaaki Kasai <high.river "\x40" gmail com>
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
use Getopt::Long;
use Git;
use strict;
use utf8;
use Encode qw(encode_utf8 decode_utf8);
use POSIX qw(strftime);
my $Program_name  = 'git-foresta';
my $Version       = '1.1.0';
my $Repo          = Git->repository($ENV{"GIT_DIR"} || ".");
my $Pretty_fmt    = "format:%H\t%at\t%an\t%C(reset)%C(auto)%d%C(reset)\t%s";
my $Reverse_order = 0;
my $Show_all      = 0;
my $Show_rebase   = 1;
my $Show_status   = 1;
my $Style         = 1;
my $Subvine_depth = 2;
my %Color         = (
  "default"      => "\e[0m",
  "tree"         => "\e[0;36m",
  "hash"         => "\e[0;35m",
  "date"         => "\e[0;34m",
  "author"       => "\e[0;33m",
  "tag"          => "\e[1;35m",

  "black"        => "\e[0;30m",
  "red"          => "\e[0;31m",
  "green"        => "\e[0;32m",
  "yellow"       => "\e[0;33m",
  "blue"         => "\e[0;34m",
  "magenta"      => "\e[0;35m",
  "cyan"         => "\e[0;36m",
  "white"        => "\e[0;37m",

  "black_bold"   => "\e[1;30m",
  "red_bold"     => "\e[1;31m",
  "green_bold"   => "\e[1;32m",
  "yellow_bold"  => "\e[1;33m",
  "blue_bold"    => "\e[1;34m",
  "magenta_bold" => "\e[1;35m",
  "cyan_bold"    => "\e[1;36m",
  "white_bold"   => "\e[1;37m",
);
my @Branch_colors_ref     = ('blue_bold', 'yellow_bold', 'magenta_bold', 'green_bold', 'cyan_bold');
my @Branch_colors_now     = ();
my $Hash_min_width        = 8;
my $Hash_width            = 0; # zero means auto
my $Date_format           = "%Y-%m-%d %H:%M";
my $Date_width            = 16;
my $Graph_margin_left     = 2;
my $Graph_margin_right    = 1;
my $Graph_symbol_commit   = '●';
my $Graph_symbol_merge    = '◎';
my $Graph_symbol_overpass = '═';
my $Graph_symbol_root     = '■';
my $Graph_symbol_tip      = '○';
my $Graph_symbol_tr       = trgen();

$SIG{'PIPE'} = 'DEFAULT'; # avoid broken pipe error

&main();

sub main
{
  Getopt::Long::Configure(qw(bundling pass_through));
  GetOptions(
    "all"                     => \$Show_all,
    "no-color"                => sub { %Color = (); },
    "no-status"               => sub { $Show_status = 0; },
    "pretty=s"                => sub {}, # ignore
    "format=s"                => sub {}, # ignore
    "reverse"                 => \$Reverse_order,
    "abbrev=i"                => \$Hash_min_width,
    "svdepth=i"               => \$Subvine_depth,
    "style=i"                 => \$Style,
    "graph-margin-left=i"     => \$Graph_margin_left,
    "graph-margin-right=i"    => \$Graph_margin_right,
    "graph-symbol-commit=s"   => sub { $Graph_symbol_commit   = decode_utf8($_[1]) },
    "graph-symbol-merge=s"    => sub { $Graph_symbol_merge    = decode_utf8($_[1]) },
    "graph-symbol-overpass=s" => sub { $Graph_symbol_overpass = decode_utf8($_[1]) },
    "graph-symbol-root=s"     => sub { $Graph_symbol_root     = decode_utf8($_[1]) },
    "graph-symbol-tip=s"      => sub { $Graph_symbol_tip      = decode_utf8($_[1]) },
    "version"                 => sub {
      print "$Program_name version $Version\n";
      exit;
    },
    "help"                    => sub {
      my $help;
      $help = "Usage: $Program_name [options]\n";
      $help = $help . "      --help                              Show this help and exit.\n";
      $help = $help . "      --svdepth=<Subvine depth>           Maximum length of merge subvines (default: 2).\n";
      $help = $help . "      --no-status                         Do not show the working tree status near HEAD.\n";
      $help = $help . "      --style=<Style>                     Select <Style> from following.\n";
      $help = $help . "                                            1   Use single-line visuals (default).\n";
      $help = $help . "                                            2   Use double-line visuals.\n";
      $help = $help . "                                            10  Use specific rounded Unicode visuals for edges.\n";
      $help = $help . "                                            15  Use single bold-line visuals.\n";
      $help = $help . "      --graph-margin-left=<Margin>        Left margin of the commit graph (default: 2).\n";
      $help = $help . "      --graph-margin-right=<Margin>       Right margin of the commit graph (default: 1).\n";
      $help = $help . "      --graph-symbol-commit=<Symbol>      Graph symbol of commit (default: ● ).\n";
      $help = $help . "      --graph-symbol-merge=<Symbol>       Graph symbol of merge (default: ◎ ).\n";
      $help = $help . "      --graph-symbol-overpass=<Symbol>    Graph symbol of overpass (default: ═ ).\n";
      $help = $help . "      --graph-symbol-root=<Symbol>        Graph symbol of root (default: ■ ).\n";
      $help = $help . "      --graph-symbol-tip=<Symbol>         Graph symbol of tip (default: ○ ).\n";
      $help = $help . "      --version                           Print the version number and exit.\n";
      $help = $help . "  All other options and arguments (except --pretty or --format) are passed down to git-log. (e.g. --all)\n";
      print encode_utf8($help);
      exit;
    },
  );
  ++$Subvine_depth;
  if (substr($Pretty_fmt, 0, 7) ne "format:") {
    die "If you use --pretty, it must be in the form of --pretty=format:";
  }
  $Pretty_fmt = substr($Pretty_fmt, 7);
  while ($Pretty_fmt =~ /\%./g) {
    if ($& eq "\%b" || $& eq "\%n" || ($&.$') =~ /^\%x0a/i) {
      die "Cannot use \%b, \%n or \%x0a in --pretty=format:";
    }
  }
  if ($Show_all) {
    #
    # Give --all back. And add HEAD to include commits
    # in the rev list that belong to a detached HEAD.
    #
    unshift @ARGV, "--all", "HEAD";
  }
  if (keys %Color > 0) {
    unshift @ARGV, '--color';
  } else {
    unshift @ARGV, '--no-color';
  }
  if ($Hash_width) {
    $Hash_width = 4 if $Hash_width < 4;
    $Hash_width = 40 if $Hash_width > 40;
  } else {
    $Hash_min_width = 40 if $Hash_min_width > 40;
    $Hash_width = maxof($Hash_min_width ,length chomped_str($Repo->command('rev-parse', '--short', 'HEAD')));
  }

  tie *STDOUT, "ReverseOutput" if $Reverse_order;
  process();
  untie *STDOUT if $Reverse_order;
}

sub get_status
{
  my $dirty = '';
  my $mid_flow = '';
  my $repo_path = $Repo->repo_path();

  my $has_change_unstaged = length $Repo->command('diff', '--shortstat');
  my $has_change_staged   = length $Repo->command('diff', '--shortstat', '--cached');
  my $has_stash           = length $Repo->command('stash', 'list');
  my $has_untracked       = length $Repo->command('ls-files', '--others', '--exclude-standard');

  $dirty = $dirty . '*' if $has_change_unstaged;
  $dirty = $dirty . '+' if $has_change_staged;
  $dirty = $dirty . '$' if $has_stash;
  $dirty = $dirty . '%' if $has_untracked;
  $dirty = ' ' . $dirty if length $dirty;

  if (-d "$repo_path/rebase-merge") {
    if (-f "$repo_path/rebase-merge/interactive") {
      $mid_flow = "|REBASE-i";
    } else {
      $mid_flow = "|REBASE-m";
    }
  } elsif (-d "$repo_path/rebase-apply") {
    if (-f "$repo_path/rebase-apply/rebasing") {
      $mid_flow = "|REBASE";
    } elsif (-f "$repo_path/rebase-apply/applying") {
      $mid_flow = "|AM";
    } else {
      $mid_flow = "|AM/REBASE";
    }
  } elsif (-f "$repo_path/MERGE_HEAD") {
    $mid_flow = "|MERGING";
  } elsif (-f "$repo_path/CHERRY_PICK_HEAD") {
    $mid_flow = "|CHERRY-PICKING";
  } elsif (-f "$repo_path/REVERT_HEAD") {
    $mid_flow = "|REVERTING";
  } elsif (-f "$repo_path/BISECT_LOG") {
    $mid_flow = "|BISECTING";
  }

  return $dirty . $mid_flow;
}

sub get_line_block
{
  my ($fh, $max) = @_;

  while (scalar(@h::ist) < $max) {
    my $x = <$fh>;

    last if !defined $x;
    push(@h::ist, $x);
  }

  my @ret = (shift @h::ist);
  for my $i (2..$max) {
    push(@ret, $h::ist[$i-2]);
  }
  return @ret;
}

sub process
{
  my @vine;
  my $refs = get_refs();
  my $status = get_status() if $Show_status;
  my ($fh, $fhc) = $Repo->command_output_pipe("log", "--date-order",
                  "--pretty=format:<%H><%h><%P>$Pretty_fmt", @ARGV);

  while (my ($line, @next_sha) = get_line_block($fh, $Subvine_depth)) {
    last if !defined $line;

    chomp $line;
    my ($sha, $mini_sha, $parents, $msg) =
      ($line =~ /^<(.*?)><(.*?)><(.*?)>(.*)/s);
    my @next_sha = map { ($_) = m{^<(.*?)>} } @next_sha;
    my @parents = split " ", $parents;
    my ($hash, $time, $author, $auto_refs, $msg) = split "\t", $msg, 5;
    my $date = strftime $Date_format, localtime($time);

    vine_branch(\@vine, $sha);

    printf "$Color{hash}%-${Hash_width}.${Hash_width}s $Color{date}%-${Date_width}s%${Graph_margin_left}s$Color{default}", $hash, $date, '';

    my $ra = vine_commit(\@vine, $sha, \@parents);
    print vis_post(vis_commit($ra));

    print ' ' x $Graph_margin_right;

    print $Color{author}, $author, $Color{default};

    if (exists($refs->{$sha})) {
      $auto_refs =~ s/[^\/]HEAD/$&$status/ if $Show_status && (grep { $_ eq 'HEAD' } @{$refs->{$sha}});
      $auto_refs =~ s/\x1b\[\d;\d\dm(?=tag: )/$Color{tag}/g if (grep { m{^refs/tags/}s } @{$refs->{$sha}});
    }

    print $auto_refs, ' ', $msg, "\n";

    vine_merge(\@vine, $sha, \@next_sha, \@parents);
  }
  $Repo->command_close_pipe($fh, $fhc);
}

sub get_next_pick
{
  my $fh = shift;
  while (defined(my $line = <$fh>)) {
    next      if $line =~ /^\s*#/;
    return $2 if $line =~ /^\S+\s+(\S+)/;
  }
  return;
}

sub get_refs
{
  my ($fh, $c) = $Repo->command_output_pipe("show-ref");
  my $ret = {};

  while (defined(my $ln = <$fh>)) {
    chomp $ln;
    next unless length $ln;

    my ($sha, $name) = ($ln =~ /^(\S+)\s+(.*)/s);
    $ret->{$sha} = [] unless exists $ret->{$sha};

    push @{$ret->{$sha}}, $name;
    if ($name =~ m{^refs/tags/}) {
      my $sub_sha = $Repo->command("log", "-1",
                    "--pretty=format:%H", $name);
      chomp $sub_sha;
      push @{$ret->{$sub_sha}}, $name if $sha ne $sub_sha;
    }
  }

  $Repo->command_close_pipe($fh, $c);

  my $rebase = -e $Repo->repo_path()."/rebase-merge/git-rebase-todo" && $Show_rebase;
  if ($rebase) {
    if (open(my $act_fh, $Repo->repo_path().
        "/rebase-merge/git-rebase-todo")) {
      my ($curr) = (<$act_fh> =~ /^\S+\s+(\S+)/);
      $curr = get_next_pick($act_fh);
      if (defined $curr) {
        $curr = $Repo->command("rev-parse", $curr);
        chomp $curr;
        unshift @{$ret->{$curr}}, "rebase/next";
      }
      close $act_fh;
    }

    chomp(my $onto = $Repo->command("rev-parse", "rebase-merge/onto"));
    unshift @{$ret->{$onto}}, "rebase/onto";
  }

  my $head = $Repo->command("rev-parse", "HEAD");
  chomp $head;

  unshift @{$ret->{$head}}, "rebase/new" if $rebase;
  unshift @{$ret->{$head}}, "HEAD";

  return $ret;
}

#
# vine_branch -
# @vine:  column array containing the expected parent IDs
# @rev:    commit ID
#
# Draws the branching vine matrix between a commit K and K^ (@rev).
#
sub vine_branch
{
  my ($vine, $rev) = @_;
  my $idx;

  my ($matched, $master) = (0, 0);
  my $ret;

  # Transform array into string
  for ($idx = 0; $idx <= $#$vine; ++$idx) {
    if (!defined $vine->[$idx]) {
      $ret .= " ";
      next;
    } elsif ($vine->[$idx] ne $rev) {
      $ret .= "I";
      next;
    }

    if (!$master && $idx % 2 == 0) {
      $ret .= "S";
      $master = 1;
    } else {
      $ret .= "s";
      $vine->[$idx] = undef;
    }
    ++$matched;
  }

  return if $matched < 2;

  remove_trailing_blanks($vine);
  printf "%-${Hash_width}.${Hash_width}s %-${Date_width}s%${Graph_margin_left}s", '', '', '';
  print vis_post(vis_fan($ret, "branch")), "\n";
}

#
# vine_commit -
# @vine:  column array containing the expected IDs
# @rev:    commit ID
# @parents:  array of parent IDs
#
sub vine_commit
{
  my ($vine, $rev, $parents) = @_;
  my $ret;

  for my $i (0..$#$vine) {
    if (!defined $vine->[$i]) {
      $ret .= " ";
    } elsif ($vine->[$i] eq $rev) {
      $ret .= "C";
    } else {
      $ret .= "I";
    }
  }

  if ($ret !~ /C/) {
    # Not having produced a C before means this is a tip
    my $i;
    for ($i = round_down2($#$vine); $i >= 0; $i -= 2) {
      if (substr($ret, $i, 1) eq " ") {
        substr($ret, $i, 1) = "t";
        $vine->[$i] = $rev;
        last;
      }
    }
    if ($i < 0) {
      if (@$vine % 2 != 0) {
        push @$vine, undef;
        $ret .= " ";
      }
      $ret .= "t";
      push @$vine, $rev;
    }
  }

  remove_trailing_blanks($vine);

  if (@$parents == 0) {
    # tree root
    $ret =~ tr/C/r/;
  } elsif (@$parents > 1) {
    # merge commit
    $ret =~ tr/C/M/;
  }

  return $ret;
}

#
# vine_merge -
# @vine:  column array containing the expected parent IDs
# @rev:    commit ID
# @next_rev:  next commit ID in the revision list
# @parents:  parent IDs of @rev
#
# Draws the merging vine matrix between a commit K (@rev) and K^ (@parents).
#
sub vine_merge
{
  my ($vine, $rev, $next_rev, $parents) = @_;
  my $orig_vine = -1;
  my @slot;
  my ($ret, $max);

  for my $i (0..$#$vine) {
    if ($vine->[$i] eq $rev) {
      $orig_vine = $i;
      last;
    }
  }

  die "vine_commit() did not add this vine." if $orig_vine == -1;

  if (@$parents <= 1) {
    #
    # A single parent does not need a visual. Update and return.
    #
    $vine->[$orig_vine] = $parents->[0];
    remove_trailing_blanks($vine);
    return;
  }

  #
  # Put previously seen branches in the vine subcolumns
  # Need to keep at least one parent for the slot algorithm below.
  #
  for (my $j = 0; $j <= $#$parents && $#$parents > 0; ++$j) {
    for (my $idx = 0; $idx <= $#$vine; ++$idx) {
      my $z = $vine->[$idx];
      if ($vine->[$idx] ne $parents->[$j] ||
          !grep { /^\Q$z\E$/ } @$next_rev) {
        next;
      }

      die "Should not really happen" if $idx == $orig_vine;

      if ($idx < $orig_vine) {
        my $p = $idx + 1;

        $p = $idx - 1 if defined $vine->[$p];
        last          if defined $vine->[$p];

        $vine->[$p] = $parents->[$j];
        str_expand(\$ret, $p + 1);
        substr($ret, $p, 1) = "s";
      } else {
        my $p = $idx - 1;

        $p = $idx + 1 if defined $vine->[$p] || $p < 0;
        last          if defined $vine->[$p];

        $vine->[$p] = $parents->[$j];
        str_expand(\$ret, $p + 1);
        substr($ret, $p, 1) = "s";
      }
      splice @$parents, $j, 1;
      --$j; # outer loop
      last; # inner loop
    }
  }

  #
  # Find some good spots to split out into and record columns
  # that will be used soon in the @slot list.
  #
  push @slot, $orig_vine;
  my $parent = 0;

  for (my $seeker = 2; $parent < $#$parents &&
      $seeker < 2 + $#$vine; ++$seeker)
  {
    my $idx = ($seeker % 2 == 0) ? -1 : 1;
    $idx *= int($seeker / 2);
    $idx *= 2;
    $idx += $orig_vine;

    if ($idx >= 0 && $idx <= $#$vine && !defined $vine->[$idx]) {
      push @slot, $idx;
      $vine->[$idx] = "0" x 40;
      ++$parent;
    }
  }
  for (my $idx = $orig_vine + 2; $parent < $#$parents; $idx += 2) {
    if (!defined $vine->[$idx]) {
      push @slot, $idx;
      ++$parent;
    }
  }

  die "Serious internal problem" if @slot != @$parents;

  @slot = sort { $a <=> $b } @slot;
  $max  = @$vine + 2 * @slot;

  for (my $i = 0; $i < $max; ++$i) {
    str_expand(\$ret, $i + 1);
    if ($#slot >= 0 && $i == $slot[0]) {
      shift @slot;
      $vine->[$i] = shift @$parents;
      substr($ret, $i, 1) = ($i == $orig_vine) ? "S" : "s";
    } elsif (substr($ret, $i, 1) eq "s") {
      ; # keep existing fanouts
    } elsif (defined $vine->[$i]) {
      substr($ret, $i, 1) = "I";
    } else {
      substr($ret, $i, 1) = " ";
    }
  }

  printf "%-${Hash_width}.${Hash_width}s %-${Date_width}s%${Graph_margin_left}s", '', '', '';
  print vis_post(vis_fan($ret, "merge")), "\n";
}

#
# vis_* - transform control string into usable graphic
#
# To cut down on code, the three vine_* functions produce only a dumb,
# but already unambiguous, control string which needs some processing
# before it is ready for public display.
#

sub vis_commit
{
  my ($s, $f) = @_;

  $s =~ s/ +$//gs;
  $s .= $f if defined $f;

  return $s;
}

sub vis_fan
{
  my $s = shift;
  my $b = shift eq "branch";

  $s =~ s{s.*s}{
    $_ = $&;
    $_ =~ tr/ I/DO/;
    $_;
  }ei;

  # Transform an ODODO.. sequence into a contiguous overpass.
  $s =~ s{O[DO]+O}{"O" x length($&)}eg;

  # Do left/right edge transformation
  $s =~ s{(s.*)S(.*s)}{vis_fan3($1, $2)}es or
  $s =~ s{(s.*)S}{vis_fan2L($1)."B"}es or
  $s =~ s{S(.*s)}{"A".vis_fan2R($1)}es or
  die "Should not come here";

  $s =~ tr/efg/xyz/ if $b;

  return $s;
}

sub vis_fan2L
{
  my $l = shift;
  $l =~ s/^s/e/;
  $l =~ s/s/f/g;
  return $l;
}

sub vis_fan2R
{
  my $r = shift;
  $r =~ s/s$/g/;
  $r =~ s/s/f/g;
  return $r;
}

sub vis_fan3
{
  my ($l, $r) = @_;
  $l =~ s/^s/e/;
  $l =~ s/s/f/g;
  $r =~ s/s$/g/;
  $r =~ s/s/f/g;
  return "${l}K$r";
}

sub vis_xfrm
{
  # A: branch to right
  # B: branch to right
  # C: commit
  # M: merge commit
  # D:
  # e: merge visual left (╔)
  # f: merge visual center (╦)
  # g: merge visual right (╗)
  # I: straight line (║)
  # K: branch visual split (╬)
  # m: single line (─)
  # O: overpass (≡)
  # r: root (╙)
  # t: tip (╓)
  # x: branch visual left (╚)
  # y: branch visual center (╩)
  # z: branch visual right (╝)
  # *: filler

  my $s = shift;
  my $spc = shift;
  if ($spc) {
    $s =~ s{[Ctr].*}{
      $_ = $&;
      $_ =~ s{ }{\*}g;
      $_;
    }esg;
  }

  # Change Branch colors
  my @s_arr_orig = split //, $s;
  my $i = 0;
  my @s_arr_odd = grep { $i++ % 2 == 0 } @s_arr_orig;

  for my $i (0 .. $#s_arr_odd) {
    if ($s_arr_odd[$i] =~ /^[efgt]$/) {
      my $j = -1;
      while ($j <= $#Branch_colors_ref) {
        $j++;
        next if $i > 0 && $Branch_colors_now[$i - 1] eq $Branch_colors_ref[$j];
        next if $Branch_colors_now[$i] eq $Branch_colors_ref[$j];
        next if $i < $#s_arr_odd && $Branch_colors_now[$i + 1] eq $Branch_colors_ref[$j];
        last;
      }
      $Branch_colors_now[$i] = $Branch_colors_ref[$j];
    }
  }


  $s =~ tr/efg.xyz/xyz.efg/ if $Reverse_order;

  if ($Style == 1) {
    $s =~ tr/ABD.efg.IKm.xyz/├┤─.┌┬┐.│┼─.└┴┘/;
  } elsif ($Style == 2) {
    $s =~ tr/ABD.efg.IKm.xyz/╠╣═.╔╦╗.║╬─.╚╩╝/;
  } elsif ($Style == 10) {
    $s =~ tr/ABD.efg.IKm.xyz/├┤─.╭┬╮.│┼─.╰┴╯/;
  } elsif ($Style == 15) {
    $s =~ tr/ABD.efg.IKm.xyz/┣┫━.┏┳┓.┃╋━.┗┻┛/;
  }

  return $Graph_symbol_tr->($s);
}

#
# vis_post - post-process/transform vine graphic
# Apply user-specific style transformation.
#
sub vis_post
{
  my ($s, $f) = @_;

  $s = vis_xfrm($s, defined $f);
  $f =~ s/^([^\x1b]+)/vis_xfrm($1)/e;
  $f =~ s/(\x1b.*?m)([^\x1b]+)/$1.vis_xfrm($2)/eg;
  if (defined $f) {
    $s =~ s/\*/$f/g;
    $s =~ s{\Q$Color{default}\E}{$&.$Color{tree}}egs;
    $s .= $f;
  }

  if ($s =~ /^(.*)([$Graph_symbol_commit$Graph_symbol_merge$Graph_symbol_root$Graph_symbol_tip])/) {
    my $branch_color = $Color{$Branch_colors_now[length($1) / 2]};
    $s =~ s/([$Graph_symbol_commit$Graph_symbol_merge$Graph_symbol_root$Graph_symbol_tip])/$branch_color$1$Color{tree}/;
  }
  return $Color{tree}, encode_utf8($s), $Color{default};
}

sub remove_trailing_blanks
{
  my $a = shift;
  pop @$a while @$a > 0 && !defined $a->[$#$a];
}

sub round_down2
{
  my $i = shift;
  return $i if $i < 0;
  return $i & ~1;
}

sub str_expand
{
  my ($r, $l) = @_;

  $$r .= " " x ($l - length $$r) if length $$r < $l;
}

sub chomped_str {
  my $str = $_[0];
  chomp $str;
  return $str;
}

sub maxof
{
  my ($x, $y) = @_;
  return ($x > $y) ? $x : $y;
}

sub trgen {
  eval qq(sub {
    my \$s = shift;
    \$s =~ tr/CMOrt/$Graph_symbol_commit$Graph_symbol_merge$Graph_symbol_overpass$Graph_symbol_root$Graph_symbol_tip/;
    return \$s;
  });
}

package ReverseOutput;
require Tie::Handle;
@ReverseOutput::ISA = qw(Tie::Handle);

sub TIEHANDLE
{
  my $class = shift;
  my $self  = {};

  open($self->{fh}, ">&STDOUT");

  return bless $self, $class;
}

sub PRINT
{
  my $self = shift;
  $self->{saved} .= join($\, @_);
}

sub PRINTF
{
  my $self = shift;
  my $format = shift;
  $self->{saved} .= sprintf($format, @_);
}

sub UNTIE
{
  my $self = shift;
  my $fh   = $self->{fh};

  print $fh join($/, reverse split(/\n/s, $self->{saved})), "\n";
  undef $self->{saved};
}
